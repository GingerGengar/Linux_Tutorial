\documentclass[a4paper, 12pt]{report}

\usepackage{comment}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{array}

\geometry{portrait, margin= 0.43in}

\def\tabsize{1.9cm}
\def\ltabsize{1.4cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{
	columns=fullflexible,
	frame=single,
	breaklines=true,
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	keepspaces=true,                 
	numbersep=5pt,                  
	tabsize=2
}


\begin{document}

\title{Arch Linux Tutorial}
\author{Ginger Gengar}
\date{$12^{th}$ July 2022}
\maketitle
\newpage

\tableofcontents
\newpage

\begin{center}












\section{Rationale}
\begin{comment}
\end{comment}
Below explains why this tutorial exists. This tutorial is only valid for Arch Linux that was personally configured. 
%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Why Use a Computer?}
\begin{comment}
\end{comment}
%Seperator
I cannot certainly speak for all users, I use a computer to help me do abstract work. Mathematics is the backbone of most major engineering fields. A lot of things in mathematics can be solved using analytical hand-written solutions, but many real-life problems cannot be solved that way. They must be solved numerically, by manual iteration. This is fine if your problem is small, but once your problem gets large enough, it becomes impossible to do by hand and instead, you have to turn to computers. 
%Seperator
\\~\\What kind of mathematical problems am I referring to? I am referring to ordinary differential equations, large matrix equations, tensor operation and even experimental symbollic computation. Why are these problems important? Solving these mathematical problems allows us to construct bridges, skyscrapers, train networks, cars, ships, aircrafts, rocketry, and most modern technologies we have today. Technology's backbone is theoretical engineering and theoretical engineering's backbone is mathematics, and mathematics can then be solved using general-purpose computers. So computers in this regard represent the last step of computing answers to. Computers are NOT A SUBSTITUTE for HUMAN THOUGHT.
%Seperator
\\~\\What other things can be done by tinkering with a computer? Automation of manufacturing, moving actuators, flying aircrafts and driving cars. Lower level electronics that can marginally be called computers also perform alot of vital tasks in multiple industries, though I am not an expert in this regard, I deal more with the theoretical computations so far. There are many other applications of computer beyond what I have discussed, but the above are already very good reasons to learn computing.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Why Use Linux?}
\begin{comment}
\end{comment}
%Seperator
One of the most astounding things I still remember to this day switching from Windows to Linux (Ubuntu) was the existence of package managers. For some reason my machine did not come with mingw, which made it incapable of compiling \texttt{C}. I spent almost 2 days trying to install mingw navigating through old sites, and being concerned of accidentally installing malware. Eventually I failed to install mingw. In Linux (Ubuntu) though, the \texttt{C} compiler \texttt{gcc} was pre-installed, and even if it wasn't, a simple command to the package manager solves all of 2 days worth of problems in just 2 minutes, not even.
%Seperator
\\~\\I also attempted to install a linear algebra library called \texttt{armadillo}. I also wanted to try out another linear algebra library \texttt{eigen}. I had to go through so many hoops installing all of the dependencies manually for \texttt{armadillo} such as \texttt{BLAS}, \texttt{SuperLU}, and others. With a linux system, a simple package manager command installs everything perfectly. So the point is, the package manager in Linux is absolutely necessary for any real programming work and is one of many great reasons to use Linux.
%Seperator
\\~\\It didn't mean much when I first started Linux, but Linux is largely customizable. The text editor, kernel version, window manager, compositor, shell, and many other utilities can be configured and customized to the user's liking. This makes the Linux operating system an incredibly personal and efficient machine. Think about the Linux operating system as a lego piece whose parts can be defined by the user themselves and chosen. This also means that no 2 Linux operating system are exactly alike because each user has their own configurations and choice of programs. 
%Seperator
\\~\\The customizability of Linux also permits a variety of workflows, including \texttt{cli}-based workflows. \texttt{cli} stands for command line interface. This is a way to use the computer that abandons the mouse altogether and does everything from just the keyboard. It is faster and easier to do many tasks that way. In this tutorial, \texttt{cli} would be used extensively.
%Seperator
The last reason I have is an ideological one, which is that the Linux operating system is part of a free operating system. Free here as define by the \texttt{GNU} does not necessarily mean free of cost (although Linux is free of cost) but instead, free here means the users are free to examine the system in great detail, learn and expand it on their own. This is important because it gives the users the reigns to how computing is done. Users can verify no malware is pre-installed on the machine, and that the computer performs up to user expectations. Users are also not dependent on corporates which is good.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Why Arch Linux?}
\begin{comment}
\end{comment}
%Seperator
A Linux distribution just means a version of Linux. Arch Linux is a Linux distribution, which means that Arch Linux is a version of the Linux operating system. To be clear, all Arch Linux systems are part of the Linux family, but not all Linux systems is Arch Linux. There are a few reasons why Arch Linux is a good Linux operating system:
%Seperator
\\~\\Arch Linux supports both binary installs and building from source. Compiled programs are translated from ther text form into machine code, which are 1's and 0's in human-unreadable form. The act of translating text format into machine code is called compilation. Binary installation is downloading those raw machine code and putting them in the appropriate directory inside the system. Building from source or source installation is downloading the human-readable text form, and then performing the compilation process on the user's machine before installing the resulting binary in the user's machine. Building from source always takes longer than binary install, but has the potential of resulting in a higher performing installed program.  Arch Linux supports both types of installs, which makes it very flexible and can install a very large variety of programs.
%Seperator
\\~\\Arch Linux is also very minimal. Minimal means that the base Arch Linux system has very few things installed in it. This means that users are free to build the system from the ground up, specifying the browser, terminal, window manager, compositor, status bar, text editor and other details themselves. A minimal system IS NOT IDEAL for users who believe an operating system should work out of the box. In a minimal system, one has to specify everything themselves, which is where the customization power of Linux is best revealed. 
%Seperator
Users who want to trade customization power for convenience should just try another distribution like Ubuntu, Linux Mint, Manjaro, etc. A non-minimal system has drawbacks when the user attempts to customize it because then the user has to uninstall unnecessary pre-installed packages, and then figure out the relationship between different packages and how to break their link and so on, which is more complicated than just configuring the system on your own. By configuring the system on your own, at least the user knows the different relationship bewteen different softwares they themselves have installed.

%Seperator
%Seperator
%Seperator
%Seperator
%Seperator
\section{Program Configuration}
\begin{comment}
\end{comment}
In this section, we will learn how to configure basic programs. 

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Basic Terminal Usage}
\begin{comment}
\end{comment}
Starting programs, writing, and almost anything can be done through the terminal. To open a new terminal press:
\begin{lstlisting}
super + enter
\end{lstlisting}
The super key is the command key, or the windows key on a typical keyboard. A new terminal instance should appear on pressing the keybinding above. To quit the terminal instances, press:
\begin{lstlisting}
ctrl + shift + w
\end{lstlisting}
These keybindings have not been changed from the default in kitty. Kitty has tabs and windows. Windows are inside a tab. To open a new tab, press:
\begin{lstlisting}
ctrl + shift + t
\end{lstlisting}
To navigate to the tab on the left
\begin{lstlisting}
ctrl + shift + left
\end{lstlisting}
To navigate to the tab on the right:
\begin{lstlisting}
ctrl + shift + right
\end{lstlisting}
Within a single tab, it is possible to open multiple windows. To do this, press:
\begin{lstlisting}
ctrl + shift + enter
\end{lstlisting}
To navigate to the left window,
\begin{lstlisting}
ctrl + shift + [
\end{lstlisting}
To navigate to the right window,
\begin{lstlisting}
ctrl + shift + ]
\end{lstlisting}
The keybinding \texttt{ctrl + shift + w} can close windows one at a time and tabs as well, try experimenting with it. To open a new tab between existing tabs, press:
\begin{lstlisting}
ctrl + t
\end{lstlisting}
This should cover the basics of terminal navigation.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Basic Window Manager Usage}
\begin{comment}
\end{comment}
Without anything else open, user resides in the first workspace. To go to the second workspace, press:
\begin{lstlisting}
super + 2
\end{lstlisting}
To go the third workspace,
\begin{lstlisting}
super + 3
\end{lstlisting}
Entering a different number will go to that workspace.  To go back to the original workspace, press:
\begin{lstlisting}
super + 1
\end{lstlisting}
Try opening 2 terminals by pressing \texttt{super + enter} twice for the two terminals. Try opening multiple tabs on one of them by pressing \texttt{ctrl + shift + t} successively for one of the terminals. To navigate between the terminal instances press:
\begin{lstlisting}
super + left
\end{lstlisting}
Alternatively, one can press:
\begin{lstlisting}
super + right
\end{lstlisting}
To make the terminal instances tile differently, One can navigate to either one of the terminal instances and press:
\begin{lstlisting}
super + shift + left
\end{lstlisting}
One can experiment with the following commands for different ways to tile the terminals:
\begin{lstlisting}
super + shift + up
super + shift + down
super + shift + right
\end{lstlisting}
One can think of the \texttt{super + shift} as the keybinding to "hold and drag" a particular terminal instance. The same logic can be applied to put terminal instances and other programs in different windows. Try navigating to one of the terminal instances and then pressing:
\begin{lstlisting}
super + shift + 2
\end{lstlisting}
Pressing different numbers will move the terminal instances or other programs to different workspaces. For example, to move a terminal instance to the third workspace, navigate to the terminal instance and press:
\begin{lstlisting}
super + shift + 3
\end{lstlisting}
The window manager also can force quit a window. To kill a particular window, navigate to it and then press:
\begin{lstlisting}
super + shift + q
\end{lstlisting}
This should cover the basics of how the window manager works.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Basic Core Utilities}
\begin{comment}
\end{comment}
To make a new file use type in the following command in a terminal instance:
\begin{lstlisting}
touch Pokemon.txt
\end{lstlisting}
\texttt{touch} is one of the core utilities in the Linux system, and the command above just means create the file named \texttt{Pokemon.txt} inside the current directory. Changing \texttt{Pokemon.txt} with another name would change the name of the file you are creating. For example, to create another file named \texttt{Digimon.dat} one can simply just type inside the terminal:
\begin{lstlisting}
touch Digimon.dat
\end{lstlisting}
One difference coming from a \texttt{Windows} operating system is that file name extensions like \texttt{.txt}, \texttt{.dat}, \texttt{.exe} in windows tell the operating system what to do with those files. In Linux, file name extensions are more like suggestions for the content inside. The operating system will not care what the extension of those files are. So in a Linux system, naming a file \texttt{Pokemon.txt} and \texttt{Pokemon.dat} will not change how the computer treats the files. Now to see the list of files and folders in the current directory, invoke the \texttt{list} command by typing in the terminal:
\begin{lstlisting}
ls
\end{lstlisting}
If you do that, then you will see the names of the files we have created in the previous prompts. The way to delete files is to invoke the \texttt{remove} command. To delete the file \texttt{Pokemon.txt} that is in the current directory, type in:
\begin{lstlisting}
rm Pokemon.txt
\end{lstlisting}
The \texttt{rm} command has to be used with great caution. Deleting a file or directory using the \texttt{rm} command IS PERMANENT. Now it is time to create directories. To make a new directory named \texttt{PokeDex} invoke the command in the terminal:
\begin{lstlisting}
mkdir PokeDex
\end{lstlisting}
Using the \texttt{list} command will give you a list of all the files and directories in a directory. There are a few ways to delete a directory. The \texttt{remove directory} command \texttt{rmdir} works if the directory is empty and has nothing in it. The \texttt{rm} command with a flag works even if the directory is not empty. To delete the directory \texttt{PokeDex}, one can invoke the command:
\begin{lstlisting}
rmdir PokeDex
\end{lstlisting}
Alternatively, one can invoke the \texttt{rm} command to also delete the directory by saying:
\begin{lstlisting}
rm -r PokeDex
\end{lstlisting}
In the above example, \texttt{-r} is a flag. We pass the \texttt{-r} flag to \texttt{rm} which means remove recursively all directories and files inside the directory \texttt{PokeDex}. After covering creation and destruction of directories, it is now important to be able to navigate between different directories. Create the directory again by invoking \texttt{mkdir PokeDex}. To navigate inside the directory \texttt{PokeDex}, say:
\begin{lstlisting}
cd  PokeDex
\end{lstlisting}
Here the \texttt{cd} command stands for change directory. To go back to the directory that contains \texttt{PokeDex}, say:
\begin{lstlisting}
cd ..
\end{lstlisting}
The command above would go back to where you once were. If you are confused about where you are in a linux system, invoke the command \texttt{pwd}. Type into the terminal:
\begin{lstlisting}
pwd
\end{lstlisting}
The command above stands for print working directory. The command above would print where you are inside the linux system. Now you might be wondering how can I rename, move files in Linux? It is possible with the \texttt{mv} command. Suppose we are at the home directory and you only have a single file \texttt{Pokemon.txt} and you would like to rename this file into \texttt{Digimon.txt}, then you can simply invoke the following command if you are inside the same directory as \texttt{Pokemon.txt}:
\begin{lstlisting}
mv Pokemon.txt Digimon.txt
\end{lstlisting}
Remember that file name extensions in linux do not mean anything, so if you wish, there is no need to even keep the \texttt{.txt} extension in the name \texttt{Digimon.txt} . Supposing you have a directory named \texttt{PokeDex}, by creating it using one the commands earlier and you wish to move the file \texttt{Digimon.txt} into the directory \texttt{PokeDex}. You can do this by invoking the command:
\begin{lstlisting}
mv Digimon.txt PokeDex
\end{lstlisting}
You can use \texttt{cd} and \texttt{ls} to verify this has been done correctly. \texttt{mv} is a versatile command, it also works for renaming and moving directories into inside other directories. For example you have $3$ directories \texttt{Games} and \texttt{Work} and \texttt{General}. You could move \texttt{Games} and \texttt{Work} to \texttt{General} by invoking the command:
\begin{lstlisting}
mv Games Work General/
\end{lstlisting}
The \texttt{cp} command stands for \texttt{copy}. This command can be used to copy directories and files. Here is an example:
\begin{lstlisting}
cp something1 AnotherThing2
\end{lstlisting}
Here \texttt{something1} can be a file, a directory, it can be anything, and \texttt{AnotherThing2} is the name of the copy. To make your life easier, just press \texttt{tab} to autocomplete the commands in the shell. Another useful command is:
\begin{lstlisting}
clear
\end{lstlisting}
This command clears the terminal of all the previus commands. There is a special directory that is meant to be user-specific. That is the home directory To go to the home directory, one can say,
\begin{lstlisting}
cd ~
\end{lstlisting}
with the \texttt{\~} character. Invoking the command,
\begin{lstlisting}
cd
\end{lstlisting}
also just immediately jumps to the home directory.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Basic Text Editing}
\begin{comment}
\end{comment}
My specific setup uses \texttt{neovim}, which is based off the famous text editor \texttt{vim}. \texttt{vim} can be a little intimidating to work with initially. There is an in-built vim tutorial. To see the in-built vim tutorial, key in to the terminal
\begin{lstlisting}
vimtutor
\end{lstlisting}
There one can use the \texttt{up} \texttt{down} arrow keys initially. The tutorial uses a vim-like keybinding. To exit the tutorial, type in the following in the vim/Neovim session,
\begin{lstlisting}
:q
\end{lstlisting}
This is also information that can be found after reading the tutorial. The tutorial does not take too long. Reading the tutorial is highly recommended. Suppose you have some text file, which you have downloaded, or created using the \texttt{touch} command, then to open a file named \texttt{Helios.txt} one can key into the terminal:
\begin{lstlisting}
nvim Helios.txt
\end{lstlisting}
in the same directory where the file \texttt{Helios.txt} resides. \texttt{nvim} is the name of the text editor, which is Neovim. \texttt{Helios.txt} is the name of the text file you wish to edit. Additional arguments may be passed to \texttt{nvim} or the classical vim editor \texttt{vim} to specify additional behaviour. For example, the terminal command,
\begin{lstlisting}
nvim -Ro Helios.txt
\end{lstlisting}
would make \texttt{Neovim} open the file \texttt{Helios.txt} in a Read Only format, so you are unable to make accidental changes to the file by default. Here I am going to discuss just the basics of editing a file, and saving a file. For full information about vim, just use the \texttt{vimtutor} command. This document will only cover the bare basics of using vim/Neovim, more advanced techniques will not be covered here. 
%Seperator
\\~\\Once you have opened a file, using the command prescribed above, Neovim/vim by default enters normal mode, which means you cannot start writing yet. To be able to edit the file, press \texttt{esc} in the vim/neovim session to enter normal mode, and then press, \texttt{i} inside the vim/Neovim session to enter "Insert" mode. After that, one can start editing the file. Even after you have done all the edits, your changes are not yet saved into the file. To save the changes into the file, firstly  press \texttt{esc} to enter normal mode again, and then press \texttt{:w} to write the changes into the file. Pressing \texttt{esc} allows you to enter normal mode. Once in normal mode, pressing \texttt{u} undos the latest changes you've made, meanwhile \texttt{ctrl + r} redos the changes you've made. 
%Seperator
\\~\\Once you are satisfied with the edits, you can quit by first entering normal mode by pressing \texttt{esc} inside the vim session, and then quitting by pressing \texttt{:q}. Remember that you should save changes to the file before quitting (vim will usually throw a warning if you attempt to quit before saving changes). When quitting, one can also do something like this from normal mode: \texttt{:wq}. The command \texttt{:wq} is a shortcut for Write and Quit. This can be an easier faster way of quitting vim. DO NOT CONSIDER TEXT EDITING A TRIVIAL TASK. TEXT EDITING IS ONE OF THE MOST IMPORTANT SKILLS FOR INTERACTING WITH THE COMPUTER.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Dotfiles \& Config Files}
\begin{comment}
\end{comment}
The terminal that is configured in this system is \texttt{kitty}. \texttt{kitty} by default does not look like it does on the machine. The colors have been changed, and the tab bars have also been changed. The font sizes have been changed and so on and so forth. The keybindings for the window manager like \texttt{super + shift + 2} to move something to workspace 2 are also modified from their original versions. How can we tell the program user-specific preferences? 
%Seperator
\\~\\The way users can specify their preferences are by writing files inside the \texttt{.config} directory in the home directory. All directories that start with a \texttt{.} are commonly known as "dotfiles". Directories that start with a \texttt{.} are assumed to be system details that the user does not need to know about. So, a simple naive \texttt{ls} command will not show all of the "dotfiles". "dotfiles" are also known as "hidden files". Additional flags can be passed to \texttt{ls} to allow it to see the "dotfiles". Navigate to the home directory by invoking the command:
\begin{lstlisting}
cd ~
\end{lstlisting}
Once there, invoke the \texttt{list} command with the flags \texttt{-a}. This will specify \texttt{list} to show all files inside the directory, including the hidden ones:
\begin{lstlisting}
ls -a
\end{lstlisting}
This may look a bit ugly, so pass the additional parameter \texttt{-l} to make it look like a list:
\begin{lstlisting}
ls -l -a
\end{lstlisting}    
This might take a long time to type, so you can make it shorter by instead invoking:
\begin{lstlisting}
ls -la
\end{lstlisting}
This is a shorter notation for \texttt{ls -l -a}. Once you have performed any of the \texttt{list} commands above, you can see the "hidden files" such as \texttt{.bashrc} and a \texttt{.config}. Navigating to the \texttt{.config} directory and then invoking the command \texttt{ls} would show all of the different programs. Navigating to one of the program directory would reveal another file. For example, navigate to the \texttt{kitty} directory. Inside that directory, there is a file \texttt{kitty.conf} and \texttt{colors.conf}. \texttt{kitty.conf} is where the user specific configurations for the \texttt{kitty} terminal resides. Changing the contents of the file \texttt{kitty.conf} with a text editor from the previous part changes the behaviour of the \texttt{kitty} terminal. The same treatment can be applied to different programs to personalize their behaviours. 
%Seperator
\\~\\What to put inside the config file of each program is all program dependent and I would not reiterate the different options here. For more details for each program, visit the individual program pages and read the appropriate documentation regarding customizing the program.

%Seperator
%Seperator
%Seperator
%Seperator
%Seperator
\section{Reading \& Writing: \LaTeX}
\begin{comment}
\end{comment}
\LaTeX is a powerful typesetting system for communicating technical ideas effectively. It is beautiful, elegant, and comprehensive. Here is a list of a few things \LaTeX can do when writing documents:
\begin{itemize}
\item Write Mathematical equations quickly and beautifully: This includes matrix equations, tensor notations, and many more
\item Write chemical equations: This is relevant for the chemists out there
\item Write clean tables: This is an important aspect of data visualization
\item Include code blocks and listings: This comes with fully customizable color and syntax highlighting
\item Draw out complex circuit diagrams: THis is for the electrical computer engineers who need to communicate circuitry across
\item Command line based, so \LaTeX is scriptable and automatic documentation can be generated 
\end{itemize}
This document is not meant to be a fully-fledged \LaTeX tutorial. I have another guide for that, discussing in greater depth how to use the \LaTeX system more effectively. This document is just to show how \LaTeX fits to my particular Arch linux setup.
%Seperator
\\~\\Writing in \LaTeX is relatively straightforward. One can just write a file containing \LaTeX code and then call the \LaTeX compiler to generate a PDF document. This PDF document can then be viewed using some PDF reader such as zathura. One needs to know how to use a PDF reader first to examine the output of the \LaTeX compiler. So it is advised to read this section sequentially.


%Seperator
%Seperator
%Seperator
%Seperator
\section{Reading PDF}
\begin{comment}
\end{comment}
The PDF reader for my particular linux setup is zathura. Suppose you have a PDF document named \texttt{Ruler.pdf} in some directory. To view the PDF document, navigate a terminal instance to the same directory \texttt{Ruler.pdf} resides in, and then invoke the command below:
\begin{lstlisting}
zathura Ruler.pdf
\end{lstlisting}
This will open a new zathura instance, showing the contents of \texttt{Ruler.pdf} . Here are a few default keybindings on how to do a basic usage of zathura:
\begin{itemize}
\item \texttt{ctrl + r} toggles dark mode and light mode. This might be useful for working at night
\item \texttt{r} simply rotates the document clockwise, this is useful for viewing landscape documents without tilting your head.
\item \texttt{d} toggles viewing $2$ pages at the same time or just $1$ page at the same time
\item \texttt{gg} goes to the beginning of the document
\item \texttt{shift + g} goes to the end of the document
\item \texttt{=} puts the document to fit the screen
\item \texttt{shitf + plus} is used to zoom into the document
\item \texttt{minus} is used to zoom out of the document
\item \texttt{ctrl + m} is used to open another instance of the same exact PDF document
\end{itemize}
It is important to know that zathura is just one PDF reader you can choose out of many. There are other PDF readers out there such as Okular, Evince, XPDF, GNU GV, Mupdf, firefox, and more. I have just made the choice of choosing zathura because of its vim-like keybindings and configurability, but each user can choose for themselves, a PDF reader they like. To demonstrate alternate PDF viewers, try opening the document not with zathura, but with firefox this time. Just like before navigate to the directory \texttt{Ruler.pdf} resides in, and then try invoking the command
\begin{lstlisting}
firefox Ruler.pdf
\end{lstlisting}
This should open a firefox instace showing the contents of \texttt{Ruler.pdf} . Yes, \texttt{firefox}, the browser, has an in-built PDF reader which makes \texttt{firefox} capable of displaying PDF documents, so firefox can be used as a PDF reader if you like.

%Seperator
%Seperator
%Seperator
%Seperator
\section{Writing \LaTeX}
\begin{comment}
\end{comment}
Suppose you have a file named \texttt{Example.tex} in some directory, then to generate the PDF document, navigate the terminal to the same directory as \texttt{Example.tex} and invoke the following terminal command:
\begin{lstlisting}
pdflatex Example.tex
\end{lstlisting}
If you are unsure what to put in the \LaTeX file initially, just copy paste the content below:
\begin{lstlisting}
\documentclass[a4paper, 12pt]{report}

\begin{document}

This is some text.

\end{document}
\end{lstlisting}
The \LaTeX code above should produce a simple one page document with the content "This is some text". The small \LaTeX code above can be used to at least learn how to compile \LaTeX documents manually. Typically though, to make life a little easier, a vim plugin was already installed called \texttt{vimtex}. This allows the compilation and viewing of a PDF to be directly handled from just inside neovim. To compile and see the document, just type in the following command while on normal mode inside a vim session opening a \texttt{.tex} file.
\begin{lstlisting}
\ll
\end{lstlisting}
To look at more features of \texttt{vimtex}, simply type in the command, inside a vim session,
\begin{lstlisting}
:help vimtex
\end{lstlisting}
To see any compilation errors, type the following while on normal mode:
\begin{lstlisting}
\le
\end{lstlisting}
To see a table of content for the document and jump to specific parts of the document, type in the following while on normal mode:
\begin{lstlisting}
\lt
\end{lstlisting}
By the end of writing and examining your first \LaTeX document, the workflow of a modular system should be clear. The general goal was to produce a document for communicating mathematical or other technical ideas. To achieve this goal, we used $3$ separate programs that only do one thing, but does that thing really well:
\begin{enumerate}
\item Neovim: Text editor to write the \LaTeX code, which is the content we want to communicate
\item \LaTeX Compiler: This converts the \LaTeX code edited from Neovim into a full-fledged PDF
\item Zathura: This is a PDF reader which allows us to see the final result of the document generated by the \LaTeX Compiler
\end{enumerate}
All of the programs shown above work well together and is used to generate the beautiful document we have written. Any of the $3$ programs above can be switched for another alternative based on whatever you, as the user want, and all of the $3$ programs above are extremely configurable, allowing the programs above to fit to the specific needs of the user. If you wish to construct even more complex tasks, the way to do it usually is not to scrap existing programs for larger more comprehensive programs, but instead to just add on newer small programs to fill the required task. For example, a workflow I have ever written for a single task looked like this:
\begin{enumerate}
\item Neovim: Text editor to write the \LaTeX code, C code, Python code, and Bash script
\item \LaTeX Compiler: This converts the \LaTeX code edited from Neovim into a full-fledged PDF. By importing a package, \LaTeX was capable of inlining computer code
\item Zathura: This is a PDF reader which allows us to see the final result of the document generated by the \LaTeX Compiler
\item GCC: a \texttt{C} language compiler that was used to convert \texttt{C} code into binary, which was used to run a theoretical simulation
\item python3: a python interpreter which was used to visualize the data generated by the \texttt{C} program and also to confirm hand-typed mathematical analytical expressions
\item Bash: a shell interpreter that "glues" the \texttt{C} and python programs together, allowing results to be generated automatically by a single command
\end{enumerate}
Each of those programs in itself is relatively small, and does only one thing but does it well. Together, the small programs could be used to construct a massively complex idea from the ground up with less human duplicate work and present it in a beautiful manner.

%Seperator
%Seperator
%Seperator
%Seperator
%Seperator
\section{Basic Programming}
\begin{comment}
\end{comment}

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Compiling Programs}
\begin{comment}
\end{comment}
Compilation is the process of taking a file with the code written in it and translating the code into machine language. Most compiled languages are going to be compiled in the exact same way. Suppose we have a C program in some directory named \texttt{c\_program.c}. To run the program, navigate a terminal instante to the same directory and then type in the following comand:
\begin{lstlisting}
gcc c_program.c
\end{lstlisting}
Use the \texttt{ls} command to see the files in the directory before and after compilation. After compilation, there will be a binary named \texttt{a.out}. To run this binary in a linux environment, type in:
\begin{lstlisting}
./a.out
\end{lstlisting}
The output of the program will then appear on the terminal console. For users without significant programming background, copy the following content into the file \texttt{c\_program.c} :
\lstinputlisting[language=c]{Hello_World.c}
Compiling and running the program shown above should result in "Hello World!" being printed into the terminal console after running with \texttt{./a.out}. More advanced compilation options would be available, but this document is not meant to delve into too much detail on \texttt{C} programming.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Running Interpreted Programs}
\begin{comment}
\end{comment}
Back in the early days of computing, there was a split in how programs ran on the computer. Two types of programming languages that arose were the compiled programs and interpreted programs. As mentioned before, compiled programs translate all of the human-readable text into machine language all at once and then running the program is just running the translated machine language as we have demonstrated in the previous subsection.
%Seperator
\\~\\Interpreted programs take on a different approach in running them. Intepreted languages like python typically have an interpreter whose task roughly is to look at the program code and go line by line. Each line, the interpreter translates the program code into machine language and then runs the translated instructions. This means that interpreted languages unlike their compiled counterparts require translation from source code into machine language every single time the program runs instead of just once for the compiled language.
%Seperator
\\~\\Interpreted programs have an inherent overhead compared to compiled languages which means that interpreted languages are much slower than their compiled counterparts. There are several advantages to having intepreters. Interpreted programs can be interrupted in the middle and new code instructions can be keyed in by the programmer. This makes debugging interpreted programs much easier compared to their compiled counterparts. So the main takeaway of an interpreted language is that it is easier to write and develop in, but it is slower when run on the computer.
%Seperator
\\~\\Suppose you have some directory with a Python program named \texttt{python\_prog.py}. To run the program, navigate a terminal instance to the directory where the program Python program resides and run the following command:
\begin{lstlisting}
python python_prog.py
\end{lstlisting}
This should run the python program. It is much simpler to run interpreted programs compared to compiled programs. Users who are unfamiliar with the python programming language can copy the code into \texttt{python\_prog.py} just to test they can succesfully run a python program:
\lstinputlisting[language=python]{Hello_World.py}
Running the program above should result in "Hello Snake!" being printed into the terminal console. Entering the terminal console and executing code from there is one great advantage of interpreted programs. To enter the console, key in the command in a terminal instance:
\begin{lstlisting}
python -i
\end{lstlisting}
From there, one can type python code and upon pressing enter, it will be executed. The following is an example:
\begin{lstlisting}
Python 3.10.5 (main, Jun  6 2022, 18:49:26) [GCC 12.1.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello World")
Hello World
>>> x = 1
>>> y = 3
>>> x+y
4
>>> print(x)
1
>>> print(y)
3
>>> print(x*x)
1
>>> print(y*y)
9
>>> 
\end{lstlisting}
To quit the python terminal, simply type in:
\begin{lstlisting}
ctrl + d
\end{lstlisting}
while inside the python console. For debugging, to enter the python terminal console after the program has finished and examine the variables directly, type in the command:
\begin{lstlisting}
python -i python_prog.py
\end{lstlisting}
This will give the user command over the python console after \texttt{python\_prog.py} has finished, allowing the programmer to examine the variables and debug the program effectively.

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Shell Scripting \& Custom Scripts}
\begin{comment}
Firstly, cover how to use permissions to make a script runnable without explicitly invoking a particular interpreter, do this with Python
Try a simple excercise of 
\end{comment}

%Seperator
%Seperator
%Seperator
%Seperator
%Seperator
\section{Basic Package Management}
\begin{comment}
How to Install programs

\end{comment}

%Seperator
%Seperator
%Seperator
%Seperator
%Seperator
\section{Learning Program Usage}
\begin{comment}
\end{comment}

%Seperator
%Seperator
%Seperator
%Seperator
%Seperator
\section{Miscellaneous}
\begin{comment}
\end{comment}

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Keybinding Summary}
\begin{comment}
\end{comment}

%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Further Reading}
\begin{comment}
\end{comment}
%Seperator
%Seperator
%Seperator
\subsubsection{General Arch Linux}
\begin{comment}
\end{comment}
The Arch Linux Wiki contains a lot of technical information. When trying to debug the system, the Arch Linux Wiki is a great rescource:
\\\url{https://wiki.archlinux.org/} 
%Seperator
%Seperator
%Seperator
\subsubsection{Kitty Terminal}
\begin{comment}
\end{comment}
This is the official page for the kitty terminal:
\\\url{https://sw.kovidgoyal.net/kitty/} 
\\The Github source code for the kitty terminal:
\\\url{https://github.com/kovidgoyal/kitty} 


%Seperator
%Seperator
%Seperator
%Seperator
\subsection{Art Gallery}
\begin{comment}
Fill with Unixporn posts
\end{comment}



























\end{center}
\end{document}
